# **Azure Reporting and Visualization Application**

This application is designed to process, analyze, and visualize data exported from a Microsoft Azure environment. It parses various CSV reports generated by Azure, normalizes the data into a relational database, and presents it through an interactive web interface. The goal is to provide a clear, consolidated view of Azure resources and recommendations, helping to identify potential cost savings, security improvements, and operational enhancements.

## **Key Features**

* **Interactive Dashboard:** A central dashboard provides a high-level overview of the environment with key performance indicators (KPIs) and summary charts.  
* **Detailed Resource Lists:** Browse, sort, and filter through lists of discovered Azure resources like Virtual Machines, VM Scale Sets, and Storage Accounts.  
* **Consolidated Recommendations:** View all Azure Advisor recommendations in a single, searchable interface, with direct links to the relevant resources in the Azure Portal.  
* **Extensible Architecture:** The application is built with a modular "plugin" architecture, making it straightforward to add support for new Azure services without modifying the core application logic.

## **Architecture Overview**

The application is built using a modern Python web stack and a modular design pattern to ensure maintainability and scalability.

* **Backend:** A **Flask** web server handles all requests, data processing, and API endpoints.  
* **Database:** **SQLAlchemy** is used as an Object-Relational Mapper (ORM) to interact with a **SQLite** database. This provides a robust and normalized data store.  
* **Frontend:** The user interface is built with standard **HTML5**, styled with **Tailwind CSS** for a clean and responsive design. Client-side interactivity and charting are powered by **JavaScript** and the **Chart.js** library.  
* **Modularity:** The core logic is separated into service "plugins". Each Azure service (e.g., Virtual Machines) is encapsulated in its own directory containing its database model, data seeding logic, and web routes. This makes the application highly extensible.

### **Project Structure**

The project follows a standard Flask application factory pattern. The app/services/ directory is the heart of the modular system, where each subdirectory represents a distinct Azure service plugin.

*A visual representation of the project's folder and file layout.*

### **Database Schema**

The database is designed around a central, polymorphic Resource table. This table stores common information for all Azure resources (like their unique Azure Resource ID, name, and location). Specific resource types (like VM or StorageAccount) inherit from this base table and add their own unique attributes. This normalized approach prevents data redundancy and ensures a single source of truth for all resources.

Recommendations are stored in their own tables and are linked to the central Resource table thanks to a relational table to describe the many to many relationship.

![DB schema](./docs/database_schema.svg)
*A diagram illustrating the relationships between the main database tables.*

## **Extending the Application**

The modular architecture makes it simple to add support for new Azure services (e.g., Key Vaults, Public IP Addresses, etc.). The process involves creating a new service "plugin" folder and defining the service's model, seeder, and routes.

For a detailed, step-by-step guide, please refer to the [**Guide to Adding a New Service**](./docs/ADDING_A_NEW_SERVICE.md).